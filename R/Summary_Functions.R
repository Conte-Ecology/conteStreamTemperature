#' @title rmse: root mean squared error
#'
#' @description
#' \code{rmse} returns root mean squared error
#'
#'@param error Vector of residual error from a model
#' @details
#' var: blah, blah, blah
#' value: something, something
#' @export
rmse <- function(error) {
  sqrt(mean(error^2))
}


#' @title mae: mean absolute error
#'
#' @description
#' \code{mae} returns mean absolute error
#'
#'@param error Vector of residual error from a model
#' @details
#' var: blah, blah, blah
#' value: something, something
#' @export
mae <- function(error) {
  mean(abs(error))
}


#' @title avgCoefs: Calculate the mean coefficient estimates from the MCMC iterations
#'
#' @description
#' \code{avgCoefs} returns a dplyr tbl_df with the mean, sd, and 95% credible intervals for each parameter
#'
#'@param ggs.obj An object generated with the ggmcmc::ggs() function that organizes the jags output mcmc.list
#'@param family Optional character string specifying the subset of the parameters to average (e.g. "B.0" for parameters B.0[1], B.0[2], B.0[3], etc.)
#' @details
#' blah, blah, blah
#' @export
avgCoefs <- function(ggs.obj, family = NULL) {
  #detach("package:ggmcmc", unload = TRUE)
  require(dplyr)
  if(class(family) == "character") {
    means <- ggs.obj %>%
      group_by(Parameter = Parameter) %>%
      filter(grepl(paste0('^', family), Parameter)) %>%
      dplyr::summarise(mean=mean(value), sd=sd(value), qLo=quantile(value,probs=c(0.025)),qHi=quantile(value,probs=c(0.975)))
  } else {
    means <- ggs.obj %>%
      group_by(Parameter = Parameter) %>%
      dplyr::summarise(mean=mean(value), sd=sd(value), qLo=quantile(value,probs=c(0.025)),qHi=quantile(value,probs=c(0.975)))
  }
  return(means)
}


#' @title nameCoefs: Match names of coefficients to the parameter names generated by coda
#'
#' @description
#' \code{nameCoefs} returns a dataframe of the coefficient summary plus the original names
#'
#' @param coef.summary Dataframe generated with the avgCoefs function
#' @param rand.levels Levels of the random effects factor (e.g. levels(as.factor(data$site)))
#' @param family Character string of the coda group names to match to the original names (e.g. "B.site")
#' @param form Formula object used for fitting the random effects indicated in family (e.g. formulae$site.form)
#' @param name Optional character string to rename the coefficient name column
#' @details
#' var: blah, blah, blah
#' value: something, something
#' @export
nameCoefs <- function (coef.summary, rand.levels, family, form = NULL, name = NULL) {
  if(class(form) == "formula") {
    B.mean <- dplyr::filter(coef.summary, grepl(paste0('^',family), coef.summary$Parameter))
    
    B.mean$index <- as.numeric(sub(".*?([0-9]+),([0-9]).", replacement = "\\1", B.mean$Parameter))
    B.mean$index2 <- as.numeric(sub(".*?([0-9]+),([0-9]).", replacement = "\\2", B.mean$Parameter))
    
    df <- data.frame(rand.levels, index = 1:length(rand.levels))
    if(class(name) == "character") {
      names(df) <- c(name, "index")
    } else {
      names(df) <- c(family, "index")
    }
    df.coef <- data.frame(coef = c("(Intercept)", attr(terms.formula(form), "term.labels")), index2 = 1:(length(attr(terms.formula(form), "term.labels")) + 1))
    
    B.mean <- dplyr::left_join(B.mean, df, by = "index")
    B.mean <- dplyr::left_join(B.mean, df.coef, by = "index2")
  } else {
    B.mean <- dplyr::filter(coef.summary, grepl(paste0('^',family), coef.summary$Parameter))
    
    B.mean$index <- as.numeric(sub(".*?([0-9]+).", replacement = "\\1", B.mean$Parameter))
    
    df <- data.frame(rand.levels, index = 1:length(rand.levels))
    if(class(name) == "character") {
      names(df) <- c(name, "index")
      } else {
        names(df) <- c(family, "index")
      }
    
    # recombine to link year and index number of the year
    B.mean <- dplyr::left_join(B.mean, df, by = "index")
  }
  
  return(B.mean)
}